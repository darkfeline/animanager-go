// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
)

const deleteAnimeFiles = `-- name: DeleteAnimeFiles :exec
DELETE FROM episode_file WHERE ROWID IN (
    SELECT episode_file.ROWID FROM episode_file
    JOIN episode ON (episode_file.eid = episode.eid)
    WHERE episode.aid=?
)
`

func (q *Queries) DeleteAnimeFiles(ctx context.Context, aid int64) error {
	_, err := q.db.ExecContext(ctx, deleteAnimeFiles, aid)
	return err
}

const deleteEpisode = `-- name: DeleteEpisode :exec
DELETE FROM episode WHERE eid = ?
`

func (q *Queries) DeleteEpisode(ctx context.Context, eid sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, deleteEpisode, eid)
	return err
}

const deleteWatching = `-- name: DeleteWatching :exec
DELETE FROM watching WHERE aid = ?
`

func (q *Queries) DeleteWatching(ctx context.Context, aid sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, deleteWatching, aid)
	return err
}

const getAIDs = `-- name: GetAIDs :many
SELECT aid FROM anime
`

func (q *Queries) GetAIDs(ctx context.Context) ([]sql.NullInt64, error) {
	rows, err := q.db.QueryContext(ctx, getAIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullInt64
	for rows.Next() {
		var aid sql.NullInt64
		if err := rows.Scan(&aid); err != nil {
			return nil, err
		}
		items = append(items, aid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAnime = `-- name: GetAllAnime :many
SELECT aid, title, type, episodecount, startdate, enddate FROM anime
`

func (q *Queries) GetAllAnime(ctx context.Context) ([]Anime, error) {
	rows, err := q.db.QueryContext(ctx, getAllAnime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Anime
	for rows.Next() {
		var i Anime
		if err := rows.Scan(
			&i.Aid,
			&i.Title,
			&i.Type,
			&i.Episodecount,
			&i.Startdate,
			&i.Enddate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllEpisodes = `-- name: GetAllEpisodes :many
SELECT eid, aid, type, number, title, length, user_watched FROM episode
`

func (q *Queries) GetAllEpisodes(ctx context.Context) ([]Episode, error) {
	rows, err := q.db.QueryContext(ctx, getAllEpisodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Episode
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.Eid,
			&i.Aid,
			&i.Type,
			&i.Number,
			&i.Title,
			&i.Length,
			&i.UserWatched,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllWatching = `-- name: GetAllWatching :many
SELECT aid, "regexp", "offset" FROM watching
`

func (q *Queries) GetAllWatching(ctx context.Context) ([]Watching, error) {
	rows, err := q.db.QueryContext(ctx, getAllWatching)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Watching
	for rows.Next() {
		var i Watching
		if err := rows.Scan(&i.Aid, &i.Regexp, &i.Offset); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnime = `-- name: GetAnime :one
SELECT aid, title, type, episodecount, startdate, enddate FROM anime WHERE aid = ?
`

func (q *Queries) GetAnime(ctx context.Context, aid sql.NullInt64) (Anime, error) {
	row := q.db.QueryRowContext(ctx, getAnime, aid)
	var i Anime
	err := row.Scan(
		&i.Aid,
		&i.Title,
		&i.Type,
		&i.Episodecount,
		&i.Startdate,
		&i.Enddate,
	)
	return i, err
}

const getAnimeCount = `-- name: GetAnimeCount :one
SELECT COUNT(*) FROM anime
`

func (q *Queries) GetAnimeCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getAnimeCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getEpisode = `-- name: GetEpisode :one
SELECT eid, aid, type, number, title, length, user_watched FROM episode WHERE eid = ? LIMIT 1
`

func (q *Queries) GetEpisode(ctx context.Context, eid sql.NullInt64) (Episode, error) {
	row := q.db.QueryRowContext(ctx, getEpisode, eid)
	var i Episode
	err := row.Scan(
		&i.Eid,
		&i.Aid,
		&i.Type,
		&i.Number,
		&i.Title,
		&i.Length,
		&i.UserWatched,
	)
	return i, err
}

const getEpisodeCount = `-- name: GetEpisodeCount :one
SELECT COUNT(*) FROM episode
`

func (q *Queries) GetEpisodeCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getEpisodeCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getEpisodeFiles = `-- name: GetEpisodeFiles :many
SELECT id, eid, path FROM episode_file WHERE eid=?
`

func (q *Queries) GetEpisodeFiles(ctx context.Context, eid int64) ([]EpisodeFile, error) {
	rows, err := q.db.QueryContext(ctx, getEpisodeFiles, eid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EpisodeFile
	for rows.Next() {
		var i EpisodeFile
		if err := rows.Scan(&i.ID, &i.Eid, &i.Path); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEpisodes = `-- name: GetEpisodes :many
SELECT eid, aid, type, number, title, length, user_watched FROM episode WHERE aid = ? ORDER BY type, number
`

func (q *Queries) GetEpisodes(ctx context.Context, aid int64) ([]Episode, error) {
	rows, err := q.db.QueryContext(ctx, getEpisodes, aid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Episode
	for rows.Next() {
		var i Episode
		if err := rows.Scan(
			&i.Eid,
			&i.Aid,
			&i.Type,
			&i.Number,
			&i.Title,
			&i.Length,
			&i.UserWatched,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWatchedEpisodeCount = `-- name: GetWatchedEpisodeCount :one
SELECT COUNT(*) FROM episode WHERE user_watched=1
`

func (q *Queries) GetWatchedEpisodeCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getWatchedEpisodeCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getWatchedMinutes = `-- name: GetWatchedMinutes :one
SELECT SUM(length) FROM episode WHERE user_watched=1
`

func (q *Queries) GetWatchedMinutes(ctx context.Context) (sql.NullFloat64, error) {
	row := q.db.QueryRowContext(ctx, getWatchedMinutes)
	var sum sql.NullFloat64
	err := row.Scan(&sum)
	return sum, err
}

const getWatching = `-- name: GetWatching :one
SELECT aid, "regexp", "offset" FROM watching WHERE aid = ?
`

func (q *Queries) GetWatching(ctx context.Context, aid sql.NullInt64) (Watching, error) {
	row := q.db.QueryRowContext(ctx, getWatching, aid)
	var i Watching
	err := row.Scan(&i.Aid, &i.Regexp, &i.Offset)
	return i, err
}

const getWatchingCount = `-- name: GetWatchingCount :one
SELECT COUNT(*) FROM watching
`

func (q *Queries) GetWatchingCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getWatchingCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const insertWatching = `-- name: InsertWatching :exec
INSERT INTO watching (aid, regexp, offset) VALUES (?, ?, ?)
ON CONFLICT (aid) DO UPDATE
SET regexp=excluded.regexp, offset=excluded.offset
WHERE aid=excluded.aid
`

type InsertWatchingParams struct {
	Aid    sql.NullInt64
	Regexp string
	Offset int64
}

func (q *Queries) InsertWatching(ctx context.Context, arg InsertWatchingParams) error {
	_, err := q.db.ExecContext(ctx, insertWatching, arg.Aid, arg.Regexp, arg.Offset)
	return err
}

const updateEpisodeDone = `-- name: UpdateEpisodeDone :exec
UPDATE episode SET user_watched = ? WHERE eid = ?
`

type UpdateEpisodeDoneParams struct {
	UserWatched int64
	Eid         sql.NullInt64
}

func (q *Queries) UpdateEpisodeDone(ctx context.Context, arg UpdateEpisodeDoneParams) error {
	_, err := q.db.ExecContext(ctx, updateEpisodeDone, arg.UserWatched, arg.Eid)
	return err
}
